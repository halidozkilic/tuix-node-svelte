import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, o as onMount, f as element, g as text, h as claim_element, j as children, k as claim_text, l as detach_dev, p as set_style, q as attr_dev, r as add_location, u as insert_hydration_dev, w as append_hydration_dev, n as noop, x as binding_callbacks, y as validate_each_argument, z as validate_each_keys, c as create_component, a as claim_component, m as mount_component, t as transition_in, b as transition_out, e as destroy_component, A as space, B as claim_space, C as check_outros, D as update_keyed_each, E as destroy_each, F as group_outros, G as destroy_block } from './client.245115e6.js';
import Row from './Row.a83c7826.js';
import { D as Draggable } from './Draggable.326cf938.js';
import './Cell.840aa8bf.js';
import './Placeholder.06d522b8.js';

/* src\routes\example.svelte generated by Svelte v3.44.1 */
const file$1 = "src\\routes\\example.svelte";

function create_fragment$1(ctx) {
	let div1;
	let div0;
	let t;

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			t = text("[=]");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true, style: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { style: true, class: true });
			var div0_nodes = children(div0);
			t = claim_text(div0_nodes, "[=]");
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_style(div0, "cursor", "grab");
			set_style(div0, "width", "20px");
			attr_dev(div0, "class", "handle");
			add_location(div0, file$1, 50, 2, 1273);
			attr_dev(div1, "class", "myitem");
			set_style(div1, "width", "100%");
			set_style(div1, "height", "80px");
			set_style(div1, "background-color", "#555");
			add_location(div1, file$1, 49, 0, 1172);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t);
			/*div0_binding*/ ctx[2](div0);
			/*div1_binding*/ ctx[3](div1);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			/*div0_binding*/ ctx[2](null);
			/*div1_binding*/ ctx[3](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function onDragStart(ev) {
	
} /*
// set cloned object and its bg color
const clone = ev.target.cloneNode(true);
clone.classList.add("clone");

draggable.dragData = {
  clone,

};
*/

function onDrop() {
	
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Example', slots, []);
	const draggable = new Draggable();
	draggable.closest = '.myitem';
	let mydiv;
	let handle;

	function onDrag(ev) {
		if (draggable.dragData && draggable.dragData.clone && !draggable.dragData.clone.parentNode) {
			document.body.appendChild(draggable.dragData.clone);
		}

		if (draggable && draggable.dragData && draggable.dragData.clone) {
			draggable.dragData.clone.style.left = ev.clientX - draggable.dragData.clone.offsetWidth / 8 + "px";
			draggable.dragData.clone.style.top = ev.clientY - draggable.dragData.clone.offsetHeight / 4 + "px";
			draggable.dragData.clone.style.background = 'orange';
		}
	}

	onMount(() => {
		draggable.setElement(mydiv, { onDragStart, onDrag, onDrop }, handle);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Example> was created with unknown prop '${key}'`);
	});

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			handle = $$value;
			$$invalidate(1, handle);
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			mydiv = $$value;
			$$invalidate(0, mydiv);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		Draggable,
		draggable,
		mydiv,
		handle,
		onDragStart,
		onDrag,
		onDrop
	});

	$$self.$inject_state = $$props => {
		if ('mydiv' in $$props) $$invalidate(0, mydiv = $$props.mydiv);
		if ('handle' in $$props) $$invalidate(1, handle = $$props.handle);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [mydiv, handle, div0_binding, div1_binding];
}

class Example extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Example",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src\routes\Form.svelte generated by Svelte v3.44.1 */
const file = "src\\routes\\Form.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[18] = list[i];
	child_ctx[19] = list;
	child_ctx[20] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[20] = i;
	return child_ctx;
}

// (216:2) {#each dropZoneItems as rows, index}
function create_each_block_1(ctx) {
	let row;
	let current;

	row = new Row({
			props: {
				placeholder: /*placeholder*/ ctx[0],
				rowIndex: /*index*/ ctx[20],
				rows: /*rows*/ ctx[21]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};
			if (dirty & /*placeholder*/ 1) row_changes.placeholder = /*placeholder*/ ctx[0];
			if (dirty & /*dropZoneItems*/ 4) row_changes.rows = /*rows*/ ctx[21];
			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(216:2) {#each dropZoneItems as rows, index}",
		ctx
	});

	return block;
}

// (222:2) {#each dragItems as item, index (item.id)}
function create_each_block(key_1, ctx) {
	let div;
	let t0_value = /*item*/ ctx[18].title + "";
	let t0;
	let t1;
	let index = /*index*/ ctx[20];
	const assign_div = () => /*div_binding*/ ctx[4](div, index);
	const unassign_div = () => /*div_binding*/ ctx[4](null, index);

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {
				class: true,
				"data-id": true,
				style: true
			});

			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "cell svelte-zdflb6");
			attr_dev(div, "data-id", /*item*/ ctx[18].id);
			set_style(div, "background-color", /*item*/ ctx[18].color);
			add_location(div, file, 222, 4, 6080);
			this.first = div;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, t1);
			assign_div();
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (index !== /*index*/ ctx[20]) {
				unassign_div();
				index = /*index*/ ctx[20];
				assign_div();
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			unassign_div();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(222:2) {#each dragItems as item, index (item.id)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div0;
	let t0;
	let div1;
	let each_blocks = [];
	let each1_lookup = new Map();
	let t1;
	let example;
	let current;
	let each_value_1 = /*dropZoneItems*/ ctx[2];
	validate_each_argument(each_value_1);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
		each_blocks_1[i] = null;
	});

	let each_value = /*dragItems*/ ctx[3];
	validate_each_argument(each_value);
	const get_key = ctx => /*item*/ ctx[18].id;
	validate_each_keys(ctx, each_value, get_each_context, get_key);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	example = new Example({ $$inline: true });

	const block = {
		c: function create() {
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t0 = space();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			create_component(example.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(div0_nodes);
			}

			div0_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true, id: true });
			var div1_nodes = children(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			claim_component(example.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "zone svelte-zdflb6");
			add_location(div0, file, 214, 0, 5859);
			attr_dev(div1, "class", "drag-list svelte-zdflb6");
			attr_dev(div1, "id", "dragList");
			add_location(div1, file, 220, 0, 5991);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div0, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].m(div0, null);
			}

			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, div1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div1, null);
			}

			insert_hydration_dev(target, t1, anchor);
			mount_component(example, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*placeholder, dropZoneItems*/ 5) {
				each_value_1 = /*dropZoneItems*/ ctx[2];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
						transition_in(each_blocks_1[i], 1);
					} else {
						each_blocks_1[i] = create_each_block_1(child_ctx);
						each_blocks_1[i].c();
						transition_in(each_blocks_1[i], 1);
						each_blocks_1[i].m(div0, null);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (dirty & /*dragItems, bindItems*/ 10) {
				each_value = /*dragItems*/ ctx[3];
				validate_each_argument(each_value);
				validate_each_keys(ctx, each_value, get_each_context, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each1_lookup, div1, destroy_block, create_each_block, null, get_each_context);
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			transition_in(example.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			each_blocks_1 = each_blocks_1.filter(Boolean);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			transition_out(example.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_each(each_blocks_1, detaching);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (detaching) detach_dev(t1);
			destroy_component(example, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function calculateHIdx(elements, left) {
	if (left > elements[1].offsetWidth / 2) {
		return Number(elements[1].id) + 1;
	} else {
		return elements[2].classList.contains("field")
		? Number(elements[2].id)
		: Number(elements[1].id);
	}
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Form', slots, []);
	const draggable = new Draggable();
	let activeArea = 25;
	let placeholder = null;
	let to;
	let dontMove;

	//export let relocate = false;
	let bindItems = [];

	//$: console.trace(placeholder);
	const COLORS = {
		brown: "#721919",
		blue: "#22228d",
		orange: "#976100",
		green: "#1f621f",
		red: "#873e3e",
		pink: "#873e75",
		gray: "#424242",
		yellow: "#767614"
	};

	let dragItems = [
		{
			id: 1,
			title: "Drag Item 1",
			color: COLORS.brown
		},
		{
			id: 2,
			title: "Drag Item 2",
			color: COLORS.green
		},
		{
			id: 3,
			title: "Drag Item 3",
			color: COLORS.pink
		},
		{
			id: 4,
			title: "Drag Item 4",
			color: COLORS.gray
		},
		{
			id: 10,
			title: "Drag Item 4",
			color: COLORS.blue
		}
	];

	let dropZoneItems = []; // [{ id: 13, title: "Item (blue)", color: COLORS.blue }],
	// [
	//   { id: 5, title: "Item (yellow)", color: COLORS.yellow },

	//   { id: 6, title: "Item (orange)", color: COLORS.orange },
	//   { id: 7, title: "Item (blue)", color: "#22228d" },
	// ],
	// [{ id: 8, title: "Item (green)", color: COLORS.green }],
	// [
	//   { id: 9, title: "Item (yellow)", color: COLORS.yellow },
	//   { id: 10, title: "Item (blue)", color: COLORS.blue },
	//   { id: 11, title: "Item (orange)", color: COLORS.orange },
	//   { id: 12, title: "Item (red)", color: COLORS.red },
	//   { id: 13, title: "Item (red)", color: COLORS.red },
	//   { id: 14, title: "Item (red)", color: COLORS.red },
	//   { id: 16, title: "Item (red)", color: COLORS.red },
	// ],
	function generatePlaceHolder(vIdx, hIdx) {
		$$invalidate(0, placeholder = {
			item: draggable.dragData.item,
			placeholder: true,
			color: "rgb(124 124 124 / 72%)",
			position: [vIdx, hIdx]
		});
	}

	function addNewCell() {
		if (placeholder.position[1] === null) {
			dropZoneItems.splice(placeholder.position[0], 0, [placeholder]);
		} else {
			dropZoneItems[placeholder.position[0]].splice(placeholder.position[1], 0, placeholder);
		}

		$$invalidate(2, dropZoneItems);
	}

	function removeCell(VIdx, HIdx) {
		if (!placeholder) return;

		if (placeholder && placeholder.position[1] === null) {
			dropZoneItems.splice(placeholder.position[0], 1);
		} else {
			dropZoneItems[placeholder.position[0]].splice(placeholder.position[1], 1);
		}

		$$invalidate(2, dropZoneItems);
		$$invalidate(0, placeholder = null);
	}

	function removePlaceHolderKey() {
		//All dropZoneItems must have same data structre
		if (placeholder && placeholder.position) $$invalidate(2, dropZoneItems[placeholder.position[0]][placeholder.position[1] || 0] = placeholder.item, dropZoneItems);
	}

	function onDragStart(ev) {
		draggable.dragData.item = dragItems.find(o => o.id === Number(ev.target.getAttribute("data-id")));
	}

	function onDrag(ev) {
		const onField = draggable.elements[1] && (draggable.elements[1].classList.contains("field") || draggable.elements[1].classList.contains("placeholder"));
		const onZone = draggable.elements[1] && draggable.elements[1].classList.contains("zone");

		if (onField && !dontMove) {
			const onHorizontal = draggable.left < activeArea || draggable.left > draggable.elements[1].offsetWidth - activeArea;
			let hIdx;
			let vIdx;
			if (draggable.elements[1].getAttribute("data-placeholder")) return;
			vIdx = calculateVIdx(draggable.elements, draggable.top, onHorizontal);

			if (vIdx === null) {
				if (placeholder !== null) {
					removeCell();
				}

				return;
			}

			if (onHorizontal) {
				hIdx = calculateHIdx(draggable.elements, draggable.left);
			} else {
				hIdx = null;
			}

			if (!placeholder) {
				generatePlaceHolder(vIdx, hIdx);
				addNewCell();
				dontMove = true;
				clearTimeout(to);

				to = setTimeout(
					() => {
						dontMove = false;
					},
					800
				);
			}

			const deletePlaceHolder = (vIdx !== placeholder.position[0] || hIdx !== placeholder.position[1]) && !draggable.elements[1].getAttribute("data-placeholder");

			if (placeholder && deletePlaceHolder) {
				removeCell();
			}
		}

		//once mouse lefts from field then delete placerholder
		if (!onField && placeholder) {
			removeCell();
		}

		//dropping first element
		if (!onField && onZone && dropZoneItems.length < 1) {
			generatePlaceHolder(0, null);
			addNewCell();
		}
	}

	function onDrop(ev) {
		removePlaceHolderKey();
		$$invalidate(0, placeholder = null);
	}

	function calculateVIdx(elements, top, onHorizontal) {
		const lineElement = elements[1].closest('.row');

		if (onHorizontal) {
			return Number(lineElement.getAttribute('id'));
		}

		if (top > lineElement.offsetHeight - activeArea) {
			return Number(lineElement.id) + 1;
		}

		if (top < activeArea) {
			return Number(lineElement.id);
		}

		return null;
	}

	onMount(() => {
		bindItems.forEach(item => {
			draggable.setElement(item, { onDragStart, onDrag, onDrop });
		});
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Form> was created with unknown prop '${key}'`);
	});

	function div_binding($$value, index) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			bindItems[index] = $$value;
			$$invalidate(1, bindItems);
			$$invalidate(3, dragItems);
		});
	}

	$$self.$capture_state = () => ({
		onMount,
		Row,
		Draggable,
		Example,
		draggable,
		activeArea,
		placeholder,
		to,
		dontMove,
		bindItems,
		COLORS,
		dragItems,
		dropZoneItems,
		generatePlaceHolder,
		addNewCell,
		removeCell,
		removePlaceHolderKey,
		onDragStart,
		onDrag,
		onDrop,
		calculateHIdx,
		calculateVIdx
	});

	$$self.$inject_state = $$props => {
		if ('activeArea' in $$props) activeArea = $$props.activeArea;
		if ('placeholder' in $$props) $$invalidate(0, placeholder = $$props.placeholder);
		if ('to' in $$props) to = $$props.to;
		if ('dontMove' in $$props) dontMove = $$props.dontMove;
		if ('bindItems' in $$props) $$invalidate(1, bindItems = $$props.bindItems);
		if ('dragItems' in $$props) $$invalidate(3, dragItems = $$props.dragItems);
		if ('dropZoneItems' in $$props) $$invalidate(2, dropZoneItems = $$props.dropZoneItems);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [placeholder, bindItems, dropZoneItems, dragItems, div_binding];
}

class Form extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Form",
			options,
			id: create_fragment.name
		});
	}
}

export { Form as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybS5mYWUxNmFkOC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JvdXRlcy9leGFtcGxlLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvRm9ybS5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSAnc3ZlbHRlJztcclxuICBpbXBvcnQgeyBEcmFnZ2FibGUgfSBmcm9tICcuL0RyYWdnYWJsZS5qcyc7XHJcblxyXG4gIGNvbnN0IGRyYWdnYWJsZSA9IG5ldyBEcmFnZ2FibGUoKTtcclxuICBkcmFnZ2FibGUuY2xvc2VzdCA9ICcubXlpdGVtJztcclxuICBsZXQgbXlkaXY7XHJcbiAgbGV0IGhhbmRsZTtcclxuXHJcbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoZXYpIHtcclxuICAgIC8qXHJcbiAgICAvLyBzZXQgY2xvbmVkIG9iamVjdCBhbmQgaXRzIGJnIGNvbG9yXHJcbiAgICBjb25zdCBjbG9uZSA9IGV2LnRhcmdldC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICBjbG9uZS5jbGFzc0xpc3QuYWRkKFwiY2xvbmVcIik7XHJcblxyXG4gICAgZHJhZ2dhYmxlLmRyYWdEYXRhID0ge1xyXG4gICAgICBjbG9uZSxcclxuXHJcbiAgICB9O1xyXG4gICAgKi9cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uRHJhZyhldikge1xyXG4gICAgaWYgKGRyYWdnYWJsZS5kcmFnRGF0YSAmJiBkcmFnZ2FibGUuZHJhZ0RhdGEuY2xvbmUgJiYgIWRyYWdnYWJsZS5kcmFnRGF0YS5jbG9uZS5wYXJlbnROb2RlKSB7XHJcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZHJhZ2dhYmxlLmRyYWdEYXRhLmNsb25lKTtcclxuICAgIH1cclxuICAgIGlmIChkcmFnZ2FibGUgJiYgZHJhZ2dhYmxlLmRyYWdEYXRhICYmIGRyYWdnYWJsZS5kcmFnRGF0YS5jbG9uZSkge1xyXG4gICAgICBkcmFnZ2FibGUuZHJhZ0RhdGEuY2xvbmUuc3R5bGUubGVmdCA9XHJcbiAgICAgICAgZXYuY2xpZW50WCAtIGRyYWdnYWJsZS5kcmFnRGF0YS5jbG9uZS5vZmZzZXRXaWR0aCAvIDggKyBcInB4XCI7XHJcbiAgICAgIGRyYWdnYWJsZS5kcmFnRGF0YS5jbG9uZS5zdHlsZS50b3AgPVxyXG4gICAgICAgIGV2LmNsaWVudFkgLSBkcmFnZ2FibGUuZHJhZ0RhdGEuY2xvbmUub2Zmc2V0SGVpZ2h0IC8gNCArIFwicHhcIjtcclxuICAgICAgZHJhZ2dhYmxlLmRyYWdEYXRhLmNsb25lLnN0eWxlLmJhY2tncm91bmQgPSAnb3JhbmdlJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gb25Ecm9wKCkge1xyXG5cclxuICB9XHJcblxyXG4gIG9uTW91bnQoKCkgPT4ge1xyXG4gICAgZHJhZ2dhYmxlLnNldEVsZW1lbnQobXlkaXYsIHtcclxuICAgICAgb25EcmFnU3RhcnQsXHJcbiAgICAgIG9uRHJhZyxcclxuICAgICAgb25Ecm9wXHJcbiAgICB9LCBoYW5kbGUpXHJcblxyXG4gIH0pO1xyXG48L3NjcmlwdD5cclxuXHJcbjxkaXYgY2xhc3M9XCJteWl0ZW1cIiBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDgwcHg7IGJhY2tncm91bmQtY29sb3I6ICM1NTU7XCIgYmluZDp0aGlzPXtteWRpdn0+XHJcbiAgPGRpdlxyXG4gICAgc3R5bGU9XCIgY3Vyc29yOiBncmFiO3dpZHRoOiAyMHB4XCJcclxuICAgIGNsYXNzPVwiaGFuZGxlXCJcclxuICAgIGJpbmQ6dGhpcz17aGFuZGxlfVxyXG4gID5cclxuICAgIFs9XVxyXG4gIDwvZGl2PlxyXG48L2Rpdj4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XHJcbiAgaW1wb3J0IFJvdyBmcm9tIFwiLi9Sb3cuc3ZlbHRlXCI7XHJcbiAgaW1wb3J0IHsgRHJhZ2dhYmxlIH0gZnJvbSBcIi4vRHJhZ2dhYmxlLmpzXCI7XHJcbiAgaW1wb3J0IEV4YW1wbGUgZnJvbSBcIi4vZXhhbXBsZS5zdmVsdGVcIjtcclxuXHJcbiAgY29uc3QgZHJhZ2dhYmxlID0gbmV3IERyYWdnYWJsZSgpO1xyXG5cclxuICBsZXQgYWN0aXZlQXJlYSA9IDI1O1xyXG4gIGxldCBwbGFjZWhvbGRlciA9IG51bGw7XHJcbiAgbGV0IHRvO1xyXG4gIGxldCBkb250TW92ZTtcclxuICAvL2V4cG9ydCBsZXQgcmVsb2NhdGUgPSBmYWxzZTtcclxuICBsZXQgYmluZEl0ZW1zID0gW107XHJcblxyXG4gIC8vJDogY29uc29sZS50cmFjZShwbGFjZWhvbGRlcik7XHJcblxyXG4gIGNvbnN0IENPTE9SUyA9IHtcclxuICAgIGJyb3duOiBcIiM3MjE5MTlcIixcclxuICAgIGJsdWU6IFwiIzIyMjI4ZFwiLFxyXG4gICAgb3JhbmdlOiBcIiM5NzYxMDBcIixcclxuICAgIGdyZWVuOiBcIiMxZjYyMWZcIixcclxuICAgIHJlZDogXCIjODczZTNlXCIsXHJcbiAgICBwaW5rOiBcIiM4NzNlNzVcIixcclxuICAgIGdyYXk6IFwiIzQyNDI0MlwiLFxyXG4gICAgeWVsbG93OiBcIiM3Njc2MTRcIixcclxuICB9O1xyXG5cclxuICBsZXQgZHJhZ0l0ZW1zID0gW1xyXG4gICAgeyBpZDogMSwgdGl0bGU6IFwiRHJhZyBJdGVtIDFcIiwgY29sb3I6IENPTE9SUy5icm93biB9LFxyXG4gICAgeyBpZDogMiwgdGl0bGU6IFwiRHJhZyBJdGVtIDJcIiwgY29sb3I6IENPTE9SUy5ncmVlbiB9LFxyXG4gICAgeyBpZDogMywgdGl0bGU6IFwiRHJhZyBJdGVtIDNcIiwgY29sb3I6IENPTE9SUy5waW5rIH0sXHJcbiAgICB7IGlkOiA0LCB0aXRsZTogXCJEcmFnIEl0ZW0gNFwiLCBjb2xvcjogQ09MT1JTLmdyYXkgfSxcclxuICAgIHsgaWQ6IDEwLCB0aXRsZTogXCJEcmFnIEl0ZW0gNFwiLCBjb2xvcjogQ09MT1JTLmJsdWUgfSxcclxuICBdO1xyXG5cclxuICBsZXQgZHJvcFpvbmVJdGVtcyA9IFtcclxuICAgIC8vIFt7IGlkOiAxMywgdGl0bGU6IFwiSXRlbSAoYmx1ZSlcIiwgY29sb3I6IENPTE9SUy5ibHVlIH1dLFxyXG4gICAgLy8gW1xyXG4gICAgLy8gICB7IGlkOiA1LCB0aXRsZTogXCJJdGVtICh5ZWxsb3cpXCIsIGNvbG9yOiBDT0xPUlMueWVsbG93IH0sXHJcbiAgICAvLyAgIHsgaWQ6IDYsIHRpdGxlOiBcIkl0ZW0gKG9yYW5nZSlcIiwgY29sb3I6IENPTE9SUy5vcmFuZ2UgfSxcclxuICAgIC8vICAgeyBpZDogNywgdGl0bGU6IFwiSXRlbSAoYmx1ZSlcIiwgY29sb3I6IFwiIzIyMjI4ZFwiIH0sXHJcbiAgICAvLyBdLFxyXG4gICAgLy8gW3sgaWQ6IDgsIHRpdGxlOiBcIkl0ZW0gKGdyZWVuKVwiLCBjb2xvcjogQ09MT1JTLmdyZWVuIH1dLFxyXG4gICAgLy8gW1xyXG4gICAgLy8gICB7IGlkOiA5LCB0aXRsZTogXCJJdGVtICh5ZWxsb3cpXCIsIGNvbG9yOiBDT0xPUlMueWVsbG93IH0sXHJcbiAgICAvLyAgIHsgaWQ6IDEwLCB0aXRsZTogXCJJdGVtIChibHVlKVwiLCBjb2xvcjogQ09MT1JTLmJsdWUgfSxcclxuICAgIC8vICAgeyBpZDogMTEsIHRpdGxlOiBcIkl0ZW0gKG9yYW5nZSlcIiwgY29sb3I6IENPTE9SUy5vcmFuZ2UgfSxcclxuICAgIC8vICAgeyBpZDogMTIsIHRpdGxlOiBcIkl0ZW0gKHJlZClcIiwgY29sb3I6IENPTE9SUy5yZWQgfSxcclxuICAgIC8vICAgeyBpZDogMTMsIHRpdGxlOiBcIkl0ZW0gKHJlZClcIiwgY29sb3I6IENPTE9SUy5yZWQgfSxcclxuICAgIC8vICAgeyBpZDogMTQsIHRpdGxlOiBcIkl0ZW0gKHJlZClcIiwgY29sb3I6IENPTE9SUy5yZWQgfSxcclxuICAgIC8vICAgeyBpZDogMTYsIHRpdGxlOiBcIkl0ZW0gKHJlZClcIiwgY29sb3I6IENPTE9SUy5yZWQgfSxcclxuICAgIC8vIF0sXHJcbiAgXTtcclxuXHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVQbGFjZUhvbGRlcih2SWR4LCBoSWR4KSB7XHJcbiAgICBwbGFjZWhvbGRlciA9IHtcclxuICAgICAgaXRlbTogZHJhZ2dhYmxlLmRyYWdEYXRhLml0ZW0sXHJcbiAgICAgIHBsYWNlaG9sZGVyOiB0cnVlLFxyXG4gICAgICBjb2xvcjogXCJyZ2IoMTI0IDEyNCAxMjQgLyA3MiUpXCIsXHJcbiAgICAgIHBvc2l0aW9uOiBbdklkeCwgaElkeF0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYWRkTmV3Q2VsbCgpIHtcclxuICAgIGlmIChwbGFjZWhvbGRlci5wb3NpdGlvblsxXSA9PT0gbnVsbCkge1xyXG4gICAgICBkcm9wWm9uZUl0ZW1zLnNwbGljZShwbGFjZWhvbGRlci5wb3NpdGlvblswXSwgMCwgW3BsYWNlaG9sZGVyXSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkcm9wWm9uZUl0ZW1zW3BsYWNlaG9sZGVyLnBvc2l0aW9uWzBdXS5zcGxpY2UoXHJcbiAgICAgICAgcGxhY2Vob2xkZXIucG9zaXRpb25bMV0sXHJcbiAgICAgICAgMCxcclxuICAgICAgICBwbGFjZWhvbGRlclxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgZHJvcFpvbmVJdGVtcyA9IGRyb3Bab25lSXRlbXM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVDZWxsKFZJZHgsIEhJZHgpIHtcclxuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybjtcclxuICAgIGlmIChwbGFjZWhvbGRlciAmJiBwbGFjZWhvbGRlci5wb3NpdGlvblsxXSA9PT0gbnVsbCkge1xyXG4gICAgICBkcm9wWm9uZUl0ZW1zLnNwbGljZShwbGFjZWhvbGRlci5wb3NpdGlvblswXSwgMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkcm9wWm9uZUl0ZW1zW3BsYWNlaG9sZGVyLnBvc2l0aW9uWzBdXS5zcGxpY2UocGxhY2Vob2xkZXIucG9zaXRpb25bMV0sIDEpO1xyXG4gICAgfVxyXG4gICAgZHJvcFpvbmVJdGVtcyA9IGRyb3Bab25lSXRlbXM7XHJcbiAgICBwbGFjZWhvbGRlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVQbGFjZUhvbGRlcktleSgpIHtcclxuICAgIC8vQWxsIGRyb3Bab25lSXRlbXMgbXVzdCBoYXZlIHNhbWUgZGF0YSBzdHJ1Y3RyZVxyXG4gICAgaWYgKHBsYWNlaG9sZGVyICYmIHBsYWNlaG9sZGVyLnBvc2l0aW9uKVxyXG4gICAgICBkcm9wWm9uZUl0ZW1zW3BsYWNlaG9sZGVyLnBvc2l0aW9uWzBdXVtwbGFjZWhvbGRlci5wb3NpdGlvblsxXSB8fCAwXSA9XHJcbiAgICAgICAgcGxhY2Vob2xkZXIuaXRlbTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGV2KSB7XHJcbiAgICBkcmFnZ2FibGUuZHJhZ0RhdGEuaXRlbSA9IGRyYWdJdGVtcy5maW5kKFxyXG4gICAgICAobykgPT4gby5pZCA9PT0gTnVtYmVyKGV2LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWlkXCIpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG9uRHJhZyhldikge1xyXG4gICAgY29uc3Qgb25GaWVsZCA9XHJcbiAgICAgIGRyYWdnYWJsZS5lbGVtZW50c1sxXSAmJlxyXG4gICAgICAoZHJhZ2dhYmxlLmVsZW1lbnRzWzFdLmNsYXNzTGlzdC5jb250YWlucyhcImZpZWxkXCIpIHx8XHJcbiAgICAgICAgZHJhZ2dhYmxlLmVsZW1lbnRzWzFdLmNsYXNzTGlzdC5jb250YWlucyhcInBsYWNlaG9sZGVyXCIpKTtcclxuXHJcbiAgICBjb25zdCBvblpvbmUgPVxyXG4gICAgICBkcmFnZ2FibGUuZWxlbWVudHNbMV0gJiYgZHJhZ2dhYmxlLmVsZW1lbnRzWzFdLmNsYXNzTGlzdC5jb250YWlucyhcInpvbmVcIik7XHJcblxyXG4gICAgaWYgKG9uRmllbGQgJiYgIWRvbnRNb3ZlKSB7XHJcbiAgICAgIGNvbnN0IG9uSG9yaXpvbnRhbCA9XHJcbiAgICAgICAgZHJhZ2dhYmxlLmxlZnQgPCBhY3RpdmVBcmVhIHx8XHJcbiAgICAgICAgZHJhZ2dhYmxlLmxlZnQgPiBkcmFnZ2FibGUuZWxlbWVudHNbMV0ub2Zmc2V0V2lkdGggLSBhY3RpdmVBcmVhO1xyXG5cclxuICAgICAgbGV0IGhJZHg7XHJcbiAgICAgIGxldCB2SWR4O1xyXG5cclxuICAgICAgaWYgKGRyYWdnYWJsZS5lbGVtZW50c1sxXS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpKSByZXR1cm47XHJcblxyXG4gICAgICB2SWR4ID0gY2FsY3VsYXRlVklkeChcclxuICAgICAgICBkcmFnZ2FibGUuZWxlbWVudHMsXHJcbiAgICAgICAgZHJhZ2dhYmxlLnRvcCxcclxuICAgICAgICBvbkhvcml6b250YWxcclxuICAgICAgKTtcclxuICAgICAgaWYgKHZJZHggPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IG51bGwpIHtcclxuICAgICAgICAgIHJlbW92ZUNlbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob25Ib3Jpem9udGFsKSB7XHJcbiAgICAgICAgaElkeCA9IGNhbGN1bGF0ZUhJZHgoZHJhZ2dhYmxlLmVsZW1lbnRzLCBkcmFnZ2FibGUubGVmdCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaElkeCA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghcGxhY2Vob2xkZXIpIHtcclxuICAgICAgICBnZW5lcmF0ZVBsYWNlSG9sZGVyKHZJZHgsIGhJZHgpO1xyXG4gICAgICAgIGFkZE5ld0NlbGwoKTtcclxuXHJcbiAgICAgICAgZG9udE1vdmUgPSB0cnVlO1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0byk7XHJcbiAgICAgICAgdG8gPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGRvbnRNb3ZlID0gZmFsc2U7XHJcbiAgICAgICAgfSwgODAwKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkZWxldGVQbGFjZUhvbGRlciA9XHJcbiAgICAgICAgKHZJZHggIT09IHBsYWNlaG9sZGVyLnBvc2l0aW9uWzBdIHx8XHJcbiAgICAgICAgICBoSWR4ICE9PSBwbGFjZWhvbGRlci5wb3NpdGlvblsxXSkgJiZcclxuICAgICAgICAhZHJhZ2dhYmxlLmVsZW1lbnRzWzFdLmdldEF0dHJpYnV0ZShcImRhdGEtcGxhY2Vob2xkZXJcIik7XHJcblxyXG4gICAgICBpZiAocGxhY2Vob2xkZXIgJiYgZGVsZXRlUGxhY2VIb2xkZXIpIHtcclxuICAgICAgICByZW1vdmVDZWxsKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL29uY2UgbW91c2UgbGVmdHMgZnJvbSBmaWVsZCB0aGVuIGRlbGV0ZSBwbGFjZXJob2xkZXJcclxuICAgIGlmICghb25GaWVsZCAmJiBwbGFjZWhvbGRlcikge1xyXG4gICAgICByZW1vdmVDZWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9kcm9wcGluZyBmaXJzdCBlbGVtZW50XHJcbiAgICBpZiAoIW9uRmllbGQgJiYgb25ab25lICYmIGRyb3Bab25lSXRlbXMubGVuZ3RoIDwgMSkge1xyXG4gICAgICBnZW5lcmF0ZVBsYWNlSG9sZGVyKDAsIG51bGwpO1xyXG4gICAgICBhZGROZXdDZWxsKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvbkRyb3AoZXYpIHtcclxuICAgIHJlbW92ZVBsYWNlSG9sZGVyS2V5KCk7XHJcbiAgICBwbGFjZWhvbGRlciA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYWxjdWxhdGVISWR4KGVsZW1lbnRzLCBsZWZ0KSB7XHJcbiAgICBpZiAobGVmdCA+IGVsZW1lbnRzWzFdLm9mZnNldFdpZHRoIC8gMikge1xyXG4gICAgICByZXR1cm4gTnVtYmVyKGVsZW1lbnRzWzFdLmlkKSArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gZWxlbWVudHNbMl0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZmllbGRcIilcclxuICAgICAgICA/IE51bWJlcihlbGVtZW50c1syXS5pZClcclxuICAgICAgICA6IE51bWJlcihlbGVtZW50c1sxXS5pZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYWxjdWxhdGVWSWR4KGVsZW1lbnRzLCB0b3AsIG9uSG9yaXpvbnRhbCkge1xyXG4gICAgY29uc3QgbGluZUVsZW1lbnQgPSBlbGVtZW50c1sxXS5jbG9zZXN0KCcucm93Jyk7XHJcblxyXG4gICAgaWYgKG9uSG9yaXpvbnRhbCkge1xyXG4gICAgICByZXR1cm4gTnVtYmVyKGxpbmVFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRvcCA+IGxpbmVFbGVtZW50Lm9mZnNldEhlaWdodCAtIGFjdGl2ZUFyZWEpIHtcclxuICAgICAgcmV0dXJuIE51bWJlcihsaW5lRWxlbWVudC5pZCkgKyAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0b3AgPCBhY3RpdmVBcmVhKSB7XHJcbiAgICAgIHJldHVybiBOdW1iZXIobGluZUVsZW1lbnQuaWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIG9uTW91bnQoKCkgPT4ge1xyXG4gICAgYmluZEl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgZHJhZ2dhYmxlLnNldEVsZW1lbnQoaXRlbSwge1xyXG4gICAgICAgIG9uRHJhZ1N0YXJ0LFxyXG4gICAgICAgIG9uRHJhZyxcclxuICAgICAgICBvbkRyb3AsXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPCEtLWRyb3Agem9uZS0tPlxyXG48ZGl2IGNsYXNzPVwiem9uZVwiPlxyXG4gIHsjZWFjaCBkcm9wWm9uZUl0ZW1zIGFzIHJvd3MsIGluZGV4fVxyXG4gICAgPFJvdyB7cGxhY2Vob2xkZXJ9IHJvd0luZGV4PXtpbmRleH0ge3Jvd3N9IC8+XHJcbiAgey9lYWNofVxyXG48L2Rpdj5cclxuXHJcbjxkaXYgY2xhc3M9XCJkcmFnLWxpc3RcIiBpZD1cImRyYWdMaXN0XCI+XHJcbiAgeyNlYWNoIGRyYWdJdGVtcyBhcyBpdGVtLCBpbmRleCAoaXRlbS5pZCl9XHJcbiAgICA8ZGl2XHJcbiAgICAgIGJpbmQ6dGhpcz17YmluZEl0ZW1zW2luZGV4XX1cclxuICAgICAgY2xhc3M9XCJjZWxsXCJcclxuICAgICAgZGF0YS1pZD17aXRlbS5pZH1cclxuICAgICAgc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOiB7aXRlbS5jb2xvcn07XCJcclxuICAgID5cclxuICAgICAge2l0ZW0udGl0bGV9XHJcbiAgICA8L2Rpdj5cclxuICB7L2VhY2h9XHJcbjwvZGl2PlxyXG5cclxuPEV4YW1wbGUgLz5cclxuXHJcbjxzdHlsZT5cclxuICA6Z2xvYmFsKGh0bWwpLFxyXG4gIDpnbG9iYWwoYm9keSkge1xyXG4gICAgbWFyZ2luOiAwO1xyXG4gICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xyXG4gIH1cclxuXHJcbiAgQGtleWZyYW1lcyB3IHtcclxuICAgIDAlIHtcclxuICAgICAgZmxleDogMDtcclxuICAgIH1cclxuICAgIDEwMCUge1xyXG4gICAgICBmbGV4OiAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQGtleWZyYW1lcyBoIHtcclxuICAgIDAlIHtcclxuICAgICAgaGVpZ2h0OiAwO1xyXG4gICAgfVxyXG4gICAgMTAwJSB7XHJcbiAgICAgIGhlaWdodDogODBweDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIDpnbG9iYWwoLnBsYWNlaG9sZGVydykge1xyXG4gICAgYW5pbWF0aW9uOiB3IDAuMnM7XHJcbiAgfVxyXG5cclxuICA6Z2xvYmFsKC5wbGFjZWhvbGRlcmgpIHtcclxuICAgIGFuaW1hdGlvbjogaCAwLjJzO1xyXG4gIH1cclxuXHJcbiAgLmNlbGwge1xyXG4gICAgZmxleDogMTtcclxuICAgIGNvbG9yOiAjYmJiO1xyXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzg4ODtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gIH1cclxuXHJcbiAgLnpvbmUge1xyXG4gICAgYm9yZGVyOiAjOTk5IDFweCBzb2xpZDtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogNTBweDtcclxuICAgIG1pbi1oZWlnaHQ6IDgwcHg7XHJcbiAgfVxyXG5cclxuICAuZHJhZy1saXN0IHtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkO1xyXG4gICAgd2lkdGg6IDIwMHB4O1xyXG4gIH1cclxuXHJcbiAgOmdsb2JhbCguY2xvbmUpIHtcclxuICAgIHdpZHRoOiAyMDBweCAhaW1wb3J0YW50O1xyXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgb3BhY2l0eTogMC42O1xyXG4gIH1cclxuPC9zdHlsZT5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXNERyxLQUVEOzs7Ozs7Ozs4QkFGQyxLQUVEOzs7Ozs7Ozs7Ozs7Ozs7OztHQVBGLG9CQVFNO0dBUEosb0JBTU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBL0NHLFdBQVcsQ0FBQyxFQUFFOzs7Ozs7Ozs7Ozs7O1NBMEJkLE1BQU07Ozs7Ozs7T0EvQlQsU0FBUyxPQUFPLFNBQVM7Q0FDL0IsU0FBUyxDQUFDLE9BQU8sR0FBRyxTQUFTO0tBQ3pCLEtBQUs7S0FDTCxNQUFNOztVQWVELE1BQU0sQ0FBQyxFQUFFO01BQ1osU0FBUyxDQUFDLFFBQVEsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxVQUFVO0dBQ3hGLFFBQVEsQ0FBQyxJQUFJLENBQUMs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
